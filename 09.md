# 9 &ndash; Base pointers
Another day, another extra field that needs to be added to the machine state. This is getting a bit awkward, as every time I change the structure of the `Intcode` type, I have to go back and edit all the previous puzzles to add the new field, even though those machines don't use it, so that they still compile.

Adding the base pointer to the code wasn't ultimately that complicated. And we're already using bignums here. The complication that is added, though, is wanting to be able to read/write outside of the bounds of the memory. I'd considered before whether this would be necessary, but never bothered to implement it as the programs we'd been given up until now all allocated extra space at the end of the program to use as scratch space. But now we needed to have the memory be an expanding array.

Haskell's base library doesn't seem to have any special handling for that... the best thing I could find for expanding an array was `ixmap`, which lets you change the array's bounds, but the values for the new array need to be mapped to values from the old array &ndash; you can't specify "hey, fill some of these values with this other specific value". So we use this to expand the array and then set all the new values to `0` as a second pass. Which seems inefficient but it works. But then I don't really have a good grasp yet as to what's efficient and what isn't in Haskell, for the time being all I care about is whether the results are correct, and this seems to work just fine.

With 9A done, 9B seems to be pretty trivial... and this seems to be borne out in the stats, less than 100 silver medals for this puzzle as I write this.
