# 12 - Getting loopy
OK, so today is a lesson in reading the entire prompt before you start thinking about the solution.

I was only a few lines into the prompt when I saw I was doing stuff with orbits and gravity and I immediately started building a Vector type to start making things like vector additions easier to write, rather than having to individually add up the coordinates in a tuple every time I wanted to do a vector addition. Because I assumed we'd be working with something resembling actual gravity calculations.

And then even when I kept reading and saw it was some highly-unreal discrete magical gravity instead, I kept using that Vector type anyway, because hey, why not. And so the [version I built for 12a](https://github.com/mrphlip/aoc2019/blob/4cb6dcbbd9e6028e1afd81209bf59105e42655ba/12.hs) was calculating the gravities and velocities for all three dimensions in tandem, using these Vector values.

Which is all well and good... until we reach part B, and it's only now that I realise that this was now detrimental... the way the gravity works in this simulation is independent on the 3 axes, so rather than taking the full position and velocity vectors of each planet and iterating them, we should just take the x-position and x-velocity for each planet and iterate that, and then do the same for the y and z. The answers for part A are the same (if ever-so-slightly clunker to get out) but part B is much easier this way, as you can figure out the cycle length individually for the three axes, and then get their least common multiple (which is a trick that was necessary to find the long cycles in the actual puzzle, but would have been near impossible to retrofit into the vector-based solution).

One trick that did save a lot of time, though, was recognising that the `step` function is reversible. From each state, not only can you find a unique _next_ state, but also a unique _previous_ state. The state-transition function is one-to-one. This means that if it does find a cycle, it has to loop all the way back to the exact _initial_ state. If it didn't, then the first repeated state would have to have two distinct predecessor states (one for the first time, the other for the loop). Which means we don't need to keep a track of every state we've visited to look for duplicates, we only need to run until we return to our initial state.
