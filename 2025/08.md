# 8 &ndash; Spanning Tree? I Hardly Even Know...ing Tree.

OK, I stumbled on this one pretty badly, but I don't think it was _entirely_ my fault. Reading through the worked example, it doesn't seem completely clear that when they say "after making the ten shortest connections", they mean _including_ the one that is skipped because it would connect two nodes that are already on the same circuit. In the prose they say that when considering two nodes that are already in the same circuit, "nothing happens", and I don't think it's clear that this is supposed to mean "you still make the connection, it still counts, it just doesn't do anything" and not "nothing happens, you don't make the connection, move on".

For a while I thought either I, or the puzzle designer, might have had an off-by-one error... if you start with `20` disconnected components, and you make `10` new edges (that only connect disconnected components) then you should end up with `10` components at the end! Not `11`! Did they stop at `9` instead of `10` by mistake while making the puzzle? Surely not.

It took me a while to even consider that maybe they meant just the first `10` _attempts_ at making a connection, and worked from there.

And even then, I still got the wrong answer, because I didn't catch that for the actual puzzle it wanted you to count to `1000`, not `10`. Which just made me doubt myself more, because doing just the first `10` connections not only gave the wrong answer, but gave the _same_ wrong answer no matter which interpretation of the puzzle I did (because `10` isn't enough connections to make a dent in the full network, it only ended up with circuits of size `2`, so both options gave an answer of `8`).

Got there in the end, though.

Part 2, ultimately, went a lot quicker, since I'd already written all the stuff for keeping track of which edges are actually connecting different components, and even keeping track of which edges are actually created, and in what order (because I assumed that would be relevant). So all I had to do was copy-paste the loop to continue to run over all the connections after the first `1000`, and the result fell out.

As for thoughts on my actual solution...

The algorithm I used wasn't quite optimal, the data structures could be tweaked a bit to work better, but what I came up with in the race was servicable. The plan is to have a mapping that lists, for each node, all the nodes it is connected to, even indirectly. To begin with, each node is only connected to itself. Then, when we are considering a new edge, we can quickly use that lookup to check whether the two nodes are connected, or if they're in separate components. If they're already connected, we skip it and move on. But if they're not connected, we add that to our list of edges, and then take the union of the two connected sets, and use that to update the connectivity lookup, for _every_ node in that component.

So, for instance, to start with the lookup looks like `{0:{0}, 1:{1}, 2:{2}, ...}`. If we then connect `0` to `1`, it'll become `{0:{0,1}, 1:{0,1}, 2:{2}, ...}`. If we then proceed to connect `0` to `2`, it'll take the union of those two components and assign it to all of them, like `{0:{0,1,2}, 1:{0,1,2}, 2:{0,1,2}, ...}`. So if we then proceed to connect `1` to `2`, we can see in the lookup that they're already connected.

This works quite well, but it does make calculating the final result for Part 1 a bit inefficient... we can easily see the size of any particular component, from the lookup, but if we want to get a list of _all_ the components, it's a bit trickier, since each component is in the lookup multiple times. The solution I ultimately went with was to iterate over each node, and only include its component if the node we're looking at is the smallest id within that component... this works to ensure each component only comes out once, but it's uncomfortably `O(n**2)`.

A better solution might have been to break the lookup into two pieces: a mapping from node index to a component index, and then a second mapping from the component index back to a set of node indexes. So, like from the example before, instead of having one mapping that looks like `{0:{0,1,2}, 1:{0,1,2}, 2:{0,1,2}, ...}` we have two mappings that look like `{0:0, 1:0, 2:0, ...}` and `{0:{0,1,2}, ...}`. This would be almost as efficient to look up connectivity, and to update when new edges are made, but would mean that the second mapping would only contain each component once, which would make finding the three largest components a lot easier.

Ultimately, though, I only thought of this improvement _after_ I'd solved Part 1, while I was working on Part 2, and so it wasn't really worth the time to make the change.

Missed the proper kickoff time again, so the times below are measured from when I actually started the puzzle.

[12:09/14:08]\*
