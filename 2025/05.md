# 5 &ndash; Ranges of ranges

Funny story, back when I was doing AoC as a way to learn Haskell, I actually had [a whole util module](../Range.hs) specifically for doing exactly this sort of thing... taking a big list of ranges, and compressing them down into an efficient data structure, complete with de-duping and merging overlapping ranges, etc. Both parts of today's puzzle would have been trivial, just plug them directly into this existing util and the answers would pop right out.

Unfortunately, I didn't have that util available in Python, so I had to [do it again](05.py) (I figured I had a better shot of just implementing the bits I needed in Python, than getting back into the swing of using Haskell, with any sort of speed).

So, even on part 1, I did the "good" thing, of properly sorting, de-duping and merging the list of ranges. And implemented looking up a value in the ranges with a binary search (as opposed to linear), for fun. The former early-optimisation helped immensely as it meant that part 2 just fell right out.

One minor stumbling block, that I got the condition the wrong way around for part 1... I thought we wanted to count the number of values that _weren't_ in the ranges, not the ones that _were_... and, of course, the provided sample has 3 of each, so it gives the same answer either way. Figured that one out pretty quickly though, and had to spend a minute in angry baby jail waiting to resubmit my answer.

I did go back, though, and [implement that util in Python](../utils/ranges.py)... it's a bit clunky, I don't like all the bits that are doing manual fiddling with iterators... but it works. And [re-implementing the solution to the puzzle](05a.py) using that util is just two lines, one for each part.

[06:30/07:06]
