# 2 &ndash; The end is never the end

Quickly realised for part 1 that it would be much nicer to build something that can iterate over the numbers with repeating digits, and then clamp that to the ranges in question, rather than iterating over the entire ranges and trying to find the numbers within that have repeating digits. Because, like, the sample in the prose only has ranges that are a dozen or so numbers long, but the ones in the actual input are ranges in the sizes of the hundreds of thousands. Which... actually probably would have been fine to just iterate over every number in that range and check it, but still.

This is fairly straight-forward, once you're going, it's pretty easy to continue generating a list of bad IDs... just increment a counter, and concatenate it to itself, like:
```py
while True:
	n += 1
	yield int(f"{n}{n}")
```
the tricky part is figuring out the endpoints. For the endpoint of the range, we just keep on counting until we're above it, and then stop. But for the start point, we need to be a bit careful.

There are two main cases:
* If the start point of the range has an even number of digits... then slice it in half, and initialise our counter to the left half. We might need to increment the counter by 1 if we're outside the range to begin with... like, if the range starts at `1200` then we initialise the counter to `12` so the first output is `1212`... but if the range starts at `1234` then we want to skip that and start at `13` with the first output being `1313`.
* However if the start point of the range has an odd number of digits, we need to skip right to the next power of `10`... like, if the range starts at `12345` then we initialise the counter to `100` so our first output is `100100`.

For part 2, we generalise the generator to generate numbers that have `k` repetitions instead of `2`... which goes quite smoothly. Replacing the even/odd check with is/is-not a multiple of `k`, replacing the output from `int(f"{n}{n}")` to `int(str(n) * k)`, everything just works.

However, the next step, which is to call this generator with all the different relevant values for `k` and collect the results, has a stumbling block of overcounting... eg a range that includes `12121212` will generate that number for both the 2-repetitions and 4-repetitions mode. At first I tried to resolve this by only generating prime numbers of repetitions... after all, _every_ 4-rep is also a 2-rep, and same for any other composite number. But this doesn't clear up _all_ the duplicates... one of the ranges in the sample input includes `222222` which is a 2-rep, a 3-rep _and_ a 6-rep. The prime check removes the 6-rep but the other two still remain. I decided to stop trying to be clever with it, and let it generate everything, and use a `set` to remove the duplicates after.

[05:22/11:29]
