# 3 &ndash; Big numbers are larger than small numbers

After two days of puzzles that were rather fiddly in their execution, it was nice to have one today that was comparatively straightforward.

The solution is very direct... because of how the number system works, we want to maximise the first digit above all other considerations. Choosing a lower first digit is always suboptimal, even if it allows the second digit to be higher.

This means that we don't need to consider all the `O(n**2)` combinations, or allow for backtracking, or anything like that... just pick the largest battery available from all the batteries that could be the first digit (ie all of them except the last one) and then once that's locked in, pick the largest of all the batteries that could be the second digit (ie all of the ones to the right of the first).

Did still manage to have one hiccup, though... I was getting the maximum battery and its location in one step by doing `val, ix = max((x, i) for i, x in enumerate(row))`... however, this formulation means that if there are multiple batteries with the same value, it'll pick the one furthest to the right (which means there are fewer batteries to choose from for digit 2). What we'd rather do is maximise the value, but _minimise_ the index. There are ways to do that with `max()` but they require some amount of _thinking_ and I'm still pretending this is a race, so instead I went with the simpler option of `val = max(row); ix = row.index(val)`... which does mean an unnecessary second pass through the list, but that's a small price to pay for not having to think too hard.

Unfortunately, this hiccup still results in the correct value for the provided sample, but the incorrect value for my actual puzzle input, so I had to do some thorough debugging to find it. Which ultimately ended up in the form of _also_ doing the naive approach of checking all `O(n**2)` possibilities and comparing it with my smarter algorithm.

I'm glad I did, though, as it was relatively straightforward to convert the smarter algorithm to part 2 (just do the same thing 12 times instead of twice) while the naive approach would have suddenly become `O(n**12)`.

[06:12/10:06]
