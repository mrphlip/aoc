# 11 &ndash; The Road Less Travelled By

Ah, a nice simple relaxing puzzle. After yesterday's 2-hour slugfest, I was worried, but this was so simple that I [solved it](11.py) for the race, and then [solved it again](11a.py) with a different strategy right afterwards, all within 10 minutes.

The main thing to realise is that the puzzle doesn't say anything about what to do if there's a loop... it doesn't say that you can only visit each node once on the path, or anything like that... so if there is a loop, then there would be potentially infinite paths, as you could go around the loop any number of times. So, as such, it's probably safe to assume that the puzzle input _has no loops_, which makes this puzzle _much_ simpler. Worst case, if we assume there are no loops, and the input does turn out to be cyclic, then the code will run forever, which will be immediately obvious since it _should_ finish almost immediately.

Process is simple: reverse the mapping so that instead of looking at a list of all the connections _from_ each server, we have a list of all the connections _to_ each server. Then the total number of routes to each server, is the number of routes to each of the servers you could come from, added together. Like, in the Part 1 sample input there's exactly one route from `you` to `bbb`, and one route from `you` to `ccc`, so since `ddd` is reachable from both `bbb` and `ccc` we add those together and find there's two routes from `you` to `ddd`. Slap some memoisation on there so that we only calcluate the count for each node once, and we're done.

For Part 2, we do the same thing, but also keep track of whether we've been through the two special nodes along the way. So essentially for Part 1 we're calculating a single route-count value for each node, while for Part 2 we're counting 4 of them: the number of direct routes, the number of routes that have gone through `fft`, the number that have gone through `dac`, and the number that have gone through both. Then we only pull out the counts that have gone through both at the end.

However, I also realised that there was a simpler option: take the existing solution from Part 1, tweak it to count the routes from any point A to point B, and use it to count the routes from `svr` to `dac`, the routes from `dac` to `fft`, and the routes from `fft` to `out`, and multiply them all together, and this will give the total number of routes `svr -> dac -> fft -> out`. Repeat this with `fft` and `dac` switched to get the other option, and add them up. Even easier, and both options still give the same answer in a matter of milliseconds.

Of course, in practice only one of those two options will be non-zero... if it was possible to get from `dac` to `fft`, and possible to get from `fft` to `dac`, that would be a cycle, and we just talked about how we can't have those. So all of the routes that go through both will do so in the same order. But I imagine which order will vary from one puzzle input to the next.

[05:37/07:53]
