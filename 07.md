# 7 - Symmetric multiprocessing
Oh boy, this one. I'm honestly surprised there aren't more silver medals for this one in the stats. I got lucky here, but I can see how some people might have had to seriously change their Intcode framework to be able to handle part B here. There is currently still a significant spike in silver medals in the [stats](https://adventofcode.com/2019/stats) (currently about 4000, where the average nearby puzzle is around 1000) but I honestly wouldn't have been surprised to see it higher.

Part A for this one was pretty simple - just run the code with one input, then take the output and run the machine again with the new input, and continue down the line. All very simple, you can just run each machine in sequence.

But part B complicates matters, and it means all the machines need to be running in tandem. If not literally in parallel, at least interleaved with each other... in a procedural language, I'd be looking at either multithreading, or coroutines. Either of which would require some rearchitecting, the inputs and outputs would need to become some sort of queue to act as a pipe between the machines, and you'd need to be able to run them until they all finished and then you extract the final value at the end.

Me, though, I got lucky, because Haskell's lazy-evaluation made it very simple - I could just feed the output list from each machine into the input list of the next. The output list of _every_ machine into the input list of the next, all the way around the circle. And it would just work, as long as the programs they were running were well-behaved enough to write enough outputs before trying to read the inputs, the lazy evaluation would mean that there were enough values to read from the input list (and if there weren't, it would start lazily-evaluating the previous machine until it generated some output).

Which is all well and good, but as I said in my notes for 5, my strategy for the outputs at this point was prepending them to a list, and then reversing that list when it was done... which meant it wasn't lazy enough. You couldn't evaluate `head outputs` for a machine until that machine had completed. Which meant it didn't work for this task. What I needed was a solution that let me properly _append_ values to the outputs, without the O(nÂ²) of `outputs' = outputs ++ [value]`, and still allowing the leading values to be read off lazily.

My solution was to borrow the trick used by `shows`. Instead of the outputs being stored as a `[Integer]`, it's stored as a `[Integer] -> [Integer]`, a function which prepends the list of outputs to whatever list you provide it. Then, appending more values is simply composing new functions onto the end, `outputs' = outputs . (value:)`. The empty list is initialised as `id`, and it's then collapsed to a simple list by evaluating `outputs []`. This lets it run in linear time, and also lets it be lazy - if you only try to read the first 2 values of the outputs, it only needs to run the machine until the first two output opcodes have been processed.

So with that working, the lazy evaluation lets me just take those output lists and effectively use them as FIFO pipes to connect each machine to the next in the loop.
