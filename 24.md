# 24 &ndash; It's Life, Jim, but not as we know it
The basic premise of this puzzle wasn't too hard to follow, as I've experimented with cellular automata and Conway's Game of Life in the past, and this setup (for part A, at least) is essentially Game of Life (but simplified somewhat by not considering diagonally-adjacent spaces, presumably to make part B easier to describe).

Part A flowed rather naturally from that, just have an array to represent the grid, and a function to iterate it to the next grid, by counting the neighbours, so far so simple.

Part B is a bit more complicated, though... at first I thought it was infinitely recurrent, as in the initial state for each level of the grid was identical... in which case, each level would always be the same after each step and we only have to consider one (just with a weird adjacency graph). But no, after further reading I see that only layer 0 has an initial state, the others all start empty. But this does give us an upper bound on how big our simulation has to be &ndash; cellular automata like this have a speed-of-light, if two points are `n` steps apart, then any change at one point will take at least `n` iterations of the automata to affect the other point. So, since any given point is 2 steps away from the same point in a neighbouring layer, in `2*n` steps it's only possible for live cells to make it to layers `n` or `-n`.

So we build our giant stack of layers, run the simulation the requisite number of times, and count up our result.

The main hiccup throughout all of this is that, up until now, I've been using the convention of having my two-dimensional arrays indexed as `(x,y)`... but for part A of this puzzle I found it more convenient to instead index as `(y,x)`... as that way the functions for iterating over the array bounds would be in row-major order, which is the order that part A wants us to use for our bitset. Indexing the array in this way means that the `toBitset` function can simply iterate over the array, in the order the array naturally wants to be iterated over. However, changing conventions at this point caused a _lot_ of typos, and there were a lot of places that were getting `x` and `y` transposed in inconsistent ways, leading to incorrect answers. Lesson learned that sometimes it's not worth changing a convention, and I should have stuck with `(x,y)` and just forced `toBitset`'s iteration to cut across the grain of the array.
