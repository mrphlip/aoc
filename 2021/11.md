# 11 &ndash; Watchen der blinkenmollusk
This one was a bit weird to implement in Haskell, because the whole flashing mechanism feels very procedural... there is a long sequence of things that happen (some octopuses flash, which increments other octopuses, which then might also flash, which propagates again, but doesn't propagate _back_ to the first octopus, and then they're all set to 0 at the end), this sequence includes potential loops, and carrying state through, and mutating the grid in various ways... all of which would be natural in a procedural langauge, but are a bit cumbersome here.

That said, once the increment function was built, the rest of the structure was pretty simple. I do love when a problem lends itself to using `unfold`, I find that function very satisfying to use. That gets us an infinite sequence of how many flashes on each step, so for part 1 we just add up the first 100 steps, and for part 2, we run it until there are 100 flashes on a single step.
