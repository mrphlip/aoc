# 17 &ndash; A puzzle to scorch the earth
This was an interesting one... it felt like more like a real _puzzle_, rather than just a coding challenge. You couldn't just take the requirements in the problem statement and turn them directly into code, you had to actually think about it to determine things like the bounds of your search space...

Take Part 1, you need to find the largest initial v<sub>y</sub> that will eventually hit the target... how do you do that by directly implementing it in code? You can keep checking larger and larger velocities, but how do you know when you've reached the point where you'll never hit the target again? You need to analyse the problem first, and once you do, you end up with an understanding of the problem that meanas you could get an exact answer by hand, without any code required.

Specifically: Ignore the x position for now, and look entirely at the y position. With how the dynamics work, the trajectory of the projectile along the y axis will be entirely symmetric &ndash; say the initial velocity was 20, so the y position starts at `[0, 20, 39...]` then it will eventually reach an apogee at `[..., 207, 209, 210, 210, 209, 207, ...]` and then continue down exactly mirroring the heights from the way up, eventually reaching `[.., 39, 20, 0, -21, ...]`.

The target area has its y values in the negatives, so this means if you have your initial v<sub>y</sub> ≥ |ymin|, the projectile will go from above the target (at 0) to below the target in one step, so you'll never hit the target, this is our upper bound for v<sub>y</sub>. However, if your initial v<sub>y</sub> = |ymin|&minus;1, then it will hit the lowest point on the target on its way down, the first step after hitting the x-axis. So this is the maximum possible initial value of v<sub>y</sub>. And once you know that, it's pretty simple to calculate how high it goes: it's just T(v<sub>y</sub>) where T(n) is the n-th [triangle number](https://en.wikipedia.org/wiki/Triangular_number).

So, we know that this initial v<sub>y</sub> value will make it so you hit the right y-range, but is there a corresponding initial v<sub>x</sub> that will work together to hit the target? Well, note that v<sub>x</sub> tends towards zero as it goes on, and once it gets there, it stays there, so once the projectile's trajectory takes a long enough time, the x position reaches a final value that is only a function of the initial v<sub>x</sub>, and not affected by v<sub>y</sub> or the time taken... you just end at x = T(v<sub>x</sub>). So, as long as (a) there is a triangle number that lies within our target x-range, and (b) the _index_ of that triangle number is less than _double_ the initial v<sub>y</sub>, then we're good, we know that maximum v<sub>y</sub> is attainable. And while I've seen some people's target areas that are in a lot of different places, I haven't seen one that's so extreme that the xmin > T(|ymin|).

For Part 2, then, we have to implement the dynamics set forth in the problem description, test a bunch of initial velocities, count which ones work. But there's still an amount of puzzling to do, to figure out how big that state-space is. For the x range, we know that v<sub>x</sub> must be positive... if it was negative, we'd be shooting away from the target (and the v<sub>x</sub> can never flip around to positive again in the trajectory). This isn't the tightest lower bound we can find, as we know that we need T(v<sub>x</sub>) ≥ xmin, but calculating the inverse of T(n) is... while not _hard_, it's also not trivial, and it only shaves off a handful of options, so I didn't bother. Meanwhile, we can't have v<sub>x</sub> > xmax, or we'll skip straight past the target in one step. So that's our bounds for v<sub>x</sub> sorted. Similarly, we can't have v<sub>y</sub> < ymin or we'll shoot straight past the target in one step, and we already figured out our maximum for v<sub>y</sub> in Part 1. So all that's left is to iterate over that range, test every point, and count up how many of them work.

[10/64]
