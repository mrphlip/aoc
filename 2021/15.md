# 15 &ndash; Stumbling through the maze
This one _seems_ like it should be easy... we need to find the shortest path through the maze, we already have a Dijkstra's algorithm solver, just throw the two together, and we're done, right?

Well, not quite... it works, but it turns out the Dijkstra's implementation I wrote a couple years ago is... not great. In particular, it works in a particularly na√Øve way, in that, on each iteration, it scans over the _entire grid_ to find the nodes that are (a) not locked in, and (b) a neighbour of a locked-in node, which are the candidates for the next step (before picking the one with the lowest value, to lock in that step).

This works well enough for smaller mazes, but for Part 2 of this puzzle we needed to work with a 500x500-cell grid, which meant that scanning across the entire grid every iteration to find those candidates took up a _lot_ of time, especially as we're scanning this massive grid, but all the weights are small so the current set of candidates is probably a pretty narrow line that gradually creeps across the grid. And it was unnecessary, as we can just keep track of this list of candidates explicitly &ndash; maintain a set of points, and every time we lock in a point, we remove it from the set, and add any of its newly-reached neighbours to the set. This was a pretty substantial change to the workings of the Dijkstra code and it basically needed to be rewritten to accommodate the change.

But it was worth it, as doing this reduced the runtime of the program from about 10 minutes, to about 15 seconds, which is a pretty decent speedup. It's also faster than the Python code I hacked together for the leaderboard race (which uses the same set-of-candidates optimisation), which takes about 30 seconds to run... I attribute the difference mostly to the fact that GHC gives me multithreading for free. Honestly, multithreading on its own probably should give an even bigger speedup factor than this, so it's likely my Haskell code is all-things-equal less efficient than the Python code, but that isn't surprising since it's a language I'm less familiar with (and also a very procedural algorithm).

The complexity of this rewrite means that even though I did this one at release for the leaderboard race in Python, I put off doing the actual Haskell implementation for a few days, because I really didn't want to have to tackle it...

Incidentally, it is relevant that the fastest path through the grid can potentially go up or left... for the sample puzzle worked through in the problem, the fastest path only goes right and down, but this is _not_ the case for (at least) my sample input &ndash; for part 1, there's a point where it goes up for two steps, and for part 2, there's a handful of different up and left steps across the route. I suspect this is a trap for the unwary problem-solver, as if you _could_ assume the path only went down and right, there is a _much_ simpler dynamic-programming solution to the problem which would give a much simpler, faster, but ultimately wrong answer to the actual input grid.

[139/59]
