# 16 &ndash; It's parsing time!
Well, that was a rush. Nothing fancy in my leaderboard-race solution, just stuffing everything into a buffer and reading the bits out piece by piece. But I got lucky in that I was able to successfully skim the instructions and read all the important info. And I'd worked with some weird file formats in the past that have unusual number-storage solutions (I'm looking at you, MIDI). So the problem wasn't too hard to wrap my head around, and it translated pretty directly into the code that got written. Which, by all accounts, was unusual, a lot of people really struggled with this one. Which lead to the gratifying leaderboard result below.

I've decided I'm going to start also committing my leaderboard-race solutions to the repo... I didn't want to do this before, since the code isn't nearly as high-quality as I'd like my published code to be... lots of bad variable names, sprawling code, and the like, which comes from writing code based off assumptions on how this needs to work, and having to go back to make changes as misunderstandings are realised, or when Part 2 changes everything... the code is an unpolished mess. But maybe it's interesting to see as a demonstration of what a race solution looks like. I've started with the script for today's puzzle, and I was able to recover a few earlier days, but most of them are lost to time at this point (many of them never existed as full-fledged scripts, but were just stuff typed into the Python REPL).

When it comes to the Haskell solution, I got to flex the parser-combinator library to parse the input, which was a bit more complicated than most things I've done with it before. That did mean that the input had to be formatted as a `String` of `'0'`s and `'1'`s (and not, say, a list of `Bool`s, or something from `Data.Bits`), which was a little unfortunate, but I decided it was worth it. The one thing that was always going to be awkward was the mode where you have to read subpackets until you've read a given number of bits from the stream... since that means whatever it recursively calls to read the subpackets has to keep track of how long they are, so every single parser function would have to return a cumulative length count, and it would all be a big pain... except that `ReadP` has this handy `gather` function which does all of that for me by magic. Without that, this solution would have been a whole lot more messy.

[5/4]
