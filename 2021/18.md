# 18 &ndash; Learning the New Math
We're definitely getting into the tail end of the month, these puzzles are getting wild.

I experimented with a couple of different ways of storing the "numbers" for this one... in particular, I tried for a bit to use a doubly-linked tree (where each node also has a link back to its parent), so that especially for the "explode" step, it can walk up the tree as needed to find the predecessor/successor leaves in the tree. But that caused other problems, especially when we're doing a lot of deep mutations on the tree, as having it doubly-linked means rebuilding the entire tree on every step, while the singly-linked option means only having to rebuild the affected node and its ancestors.

So instead, for the "explode" step, when we walk the tree trying to find the node (if any) which we need to explode, we also keep track of _where_ in the tree the node is, in terms of whether it's going left or right at each branch, and then we can easily take that "address" list, and turn it into the addresses of the predecessor/successor. For instance, to find the predecessor, we need to (a) as long as our node is the left branch of its parent, go up a level in the tree, (b) once we get to a node where we're the right branch, move over to the left branch (c) keep following the right branches until we reach a leaf node. This corresponds to taking the address, trimming any "Left" steps off the end, changing the last "Right" to a "Left", and then appending as many "Right"s as needed. This is an operation we can do to the address list, without even needing to inspect the actual tree shape, which is handy.

Comparatively, implementing the "split" step is much more straightforward &ndash; we already have figured out how to walk the tree looking for nodes with specific criteria, and once we find it, we just need to replace that node with a different node, not wander the tree looking for neighbours. Implementing the "magnitude" calculation, and the search for part 2, is also straightforward.

Comparatively, when I was coding for the leaderboard race, I was implementing it in Python, and the reduction operations worked by directly mutating the values in the lists... which worked great for the first part, as each value was only being used once. But then the second part failed, as every value from the input list needed to have calculations done with it multiple times, and they were being scrambled by the previous calculations, leaving me with the wrong answers. The actual fix for this was pretty simple, just adding a call to `deepcopy`, but it took a bit to realise that this was the problem I was having...

[7/9]
