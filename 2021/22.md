# 22 &ndash; Should've been solving these in Mondrian
My race solutions for this one were so wildly different, that I actually have them uploaded as multiple separate files. I have [one file for my Part 1 solution](22a.py), [one file for my Part 2 solution](22b.py), and [one file with a more efficient solution to Part 2](22c.py) (which I was working on while the first Part 2 solution was running, but didn't quite finish before the inefficient solution completed, so I just used that).

The solution for Part 1 was just to solve this directly... make the full millionish-element 3d grid of switches, and switch them on or off as appropriate while going through the list of operations. Even though it was pretty obvious that Part 2 was going to be "ok, now do it on the quadrillionish-element full grid", I just wanted to get the first part done and out the door for the race before worring about that.

For Part 2, my solution was pretty straightforward, but fiddly: I want to store the set of active switches in terms of a union of disjoint cuboid regions. So if we have to work with two regions that intersect, we subdivide those regions up into smaller cuboids, so that the intersection is a single cuboid region that we can add/remove on its own, and then handle each one separately.

For example, picture we have one cuboid going from `(0,0,0)..(10,10,10)` and another going from `(5,5,5)..(15,15,15)`. We want to split these up so that we have the intersecting region, going from `(5,5,5)..(10,10,10)` as one region, and then we have the two difference regions (which look like cubes with a chunk cut out of one corner), and since that shape is awkward to work with, we subdivide each of those up to decompose them into cuboids.

For my more inefficient solution, I went with the direct approach, and in this case I'd divide both of the cuboid regions into 8 octants. So the first cuboid would be split into `(0,0,0)..(4,4,4)`, `(0,0,5)..(4,4,10)`, etc. So each would be divided into 8 pieces, of which 1 piece was shared between the two, so we'd end up with the union of the two original regions being described as a set of 15 cuboids.

For the more efficient solution, I work through one axis at a time... so the first cuboid would be split into `(0,0,0)..(4,10,10)`, `(5,0,0)..(10,4,10)`, `(5,5,0)..(10,10,4)` and `(5,5,5)..(10,10,10)`. The other region gets similarly split into 4 pieces, 1 piece is shared between the two partitions, so we'd end up with the region being described as a set of 7 cuboids. Considering the potentially-exponential growth of these regions as the puzzle progresses, and new regions potentially start intersecting multiple existing regions, this causes a significant speedup... in practice my runtime went from 10 minutes for the inefficient version, down to 3 minutes for the faster version.

When I went to re-implement this in Haskell, I realised I could go one step further: I only need to subdivide one of the two regions. So the first region I subdivide as before in the efficient Python solution, but the second region I keep as the full `(5,5,5)..(15,15,15)`. So now the full region is being described with only 4 cuboids, which I think is minimal. This version runs in under a second, but I don't know how much of this speedup is due to faster algorithms and how much is due to the switch of language and environment...

[26/26]
