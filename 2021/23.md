# 23 &ndash; Block-pushing puzzles are everyone's favourite
This one was a comedy of errors.

So, I looked at the puzzle as described, and realised, that this _could_ be solved by a standard path-finding algorithm, but to my eye it looked like Dijkstra's algorithm would be a poor fit. Because the weights of some of the actions are _so much_ larger than the other actions, an application of Dijkstra's would explore basically the entire statespace accessible by moving A's B's and C's in the maze, before it would ever consider moving a D. And then it would continue exploring just moving A's B's and C's before it would consider moving the next D. It would work, but it would be a thoroughly inefficient way to solve the problem. This is exactly the sort of problem that A* is good at fixing, but unfortunately that algorithm was a blind spot for me, I knew it existed but I'd never learned exactly how it worked, and I didn't think that in the middle of a race situation was the time to start. So, mistake 1: I should have looked into A* immediately, it was not as complicated as I feared (it's basically Dijkstra's with just a small change to the node selection step).

So, with the available programmatic solutions ruled out, I started trying to solve the puzzle by hand. And I got reasonably far. Though I did discover that AoC gets grumpy with you if it thinks you're guessing... normally there's a rate limit that you can only submit one guess per minute, but once you've had 5 wrong guesses the rate limit jumps to one guess every _five_ minutes. I didn't know that was a thing until I started tackling this puzzle. Because it's a challenging one to solve by hand &ndash; finding a solution to get all the amphipods home is one thing, but finding _the optimal_ solution is another. And once you find a solution, knowing it's _the_ optimal solution is hard to know for sure.

But after 23 minutes, I do manage to get a solution, and I'm on to Part 2. And nothing in the new part makes me think that solving this with code is going to get any easier, so I keep on trying to solve it by hand, and I get _nowhere_. Did you know that once you've had 10 wrong guesses, the rate limit jumps again, to one guess every _ten_ minutes? I do, now. I kept trying different strategies, and different analyses, and got nowhere.

After about an hour of staring at this puzzle (and knowing that top-100 is off the table), I gave up, and coded up the Dijkstra'a solver. And, as I expected, the performance is _terrible_, it doesn't even seem capable of solving Part 1. (Testing it later, it is able to solve Part 1, but it takes 12 minutes to do so... Part 2 is off the table.) So I give up, and crack open the Wikipdia page for A* and discover how simple that is, and build that. It solves Part 1 in about 3 seconds.

However, for Part 2, it struggles. Because, it turns out, I've been completely misreading the instructions. The instructions give three rules: (1) the amphipods won't stop directly outside a room, (2) they will only enter a room if it's been emptied of anyone who doesn't belong there, and (3) they will not move from a hallway location to another hallway location. The effect of rules 2 and 3 in particular mean that each amphipod will only ever move twice: once from its starting location to the hallway, and again from the hallway to its finishing location in its home. But when I was speed-reading the rules for the race, I got rule 2 understood correctly, but I misread rule 1 (I thought it meant they will only avoid standing directly in front of the room _they just left_, not that they'll avoid standing in front of _any_ room). And I completely missed rule 3 entirely, just totally didn't read it at all.

I discovered these errors while I was working on trying to solve part 2 by hand, it's part of why I struggled so much with that solve. And it's part of why I thought Dijkstra's would be useless... if you can have a couple of A's just dancing around in the hallway all day, very slowly racking up energy, it'll take forever for that to add up to 2000 energy, at which point it'll even consider moving a D. Having a rule in there that limits those sorts of shenanigans makes it much more feasible. So that's mistake 2: actually read the rules of the puzzle.

With those issues out of the way, though, the solver was able to solve Part 2 in about 18 seconds, and get me the answer. But after half an hour manually solving Part 1, an hour trying and failing to manually solve Part 2, and an hour implementing a broken Dijkstra's and then learning an implementing A* which worked, I was well outside of the leaderboard.

Bringing this solution into Haskell was also a challenge, as I had a Dijkstra's implementation handy, but it wasn't easily amenable to being adapted to A* and also it only worked on inputs that could be laid out on a grid (as it had been written as a maze-solver in the past) and less useful to a more abstract graph like this maze state-space. So I had to re-implement it using different data-structures. And ultimately I'm not entirely pleased with the result... my Haskell version of this solution takes 4.5 minutes to run, while the Python version takes just 20 seconds, and I'm not entirely certain where the slowdown is, there's a lot of weird data manipulation that happens in this puzzle. But, it's working, I'm gonna call it a success and move on.

[267/872]
