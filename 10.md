# 10 &ndash; Direction tracking
A lot of other solutions I've seen for this challenge involve measuring the _angles_ between points, and comparing `atan` vs `atan2` and similar modes of thought. But I really wanted to avoid using floats for this.

I mean, in theory `atan2(1,3)` and `atan2(2,6)` should give exactly the same answer. 1, 2, 3 and 6 can all be exactly represented as floats, so even if `1/3` and `atan(1/3)` can't be exactly represented, they should still be exactly equal to `2/6` and `atan(2/6)` respectively. And we certainly shouldn't have any points close enough together that their angles would round to the same value. So in theory we _shouldn't_ have to worry about rounding errors here. But I'd rather not think about it at all, and risk that maybe I've missed something that would let a rounding error slip in.

So instead I wanted to do everything with `Rational` and gradients, it seemed like a perfect fit. Except we're talking about _rays_, not _lines_... `(1,1)` and `(&minus;1,&minus;1)` needed to be considered as different directions. And also `(0,1)` needed to be a valid direction, even though its gradient is undefined.

And so, I rolled my own `Rational`-like object, which works the same way, except that two objects are only considered the same if their ratios match _and_ their signs match. And either coordinate is allowed to be zero.

Then part A is as simple as taking the directions to all the stars, and counting the unique values (by converting it to a set, and then back to a list, to remove duplicates), and finding the point where that value is maximised (see previous comment about always wanting to use `maximumBy func` instead of ``maximumBy (compare `on` func)`` until the compiler yells at me).

Part B was also not super hard... it meant adding a proper ordering function for my `Rational`-alike (I'd built an arbitrary ordering function for part A, as `Set` requires it, but the ordering it used didn't make a lot of sense... now we wanted it to be clockwise). And then the algorithm is simply: group the asteroids by their direction, then sort each group by distance. Then we want to pull the first element from each list, then the second, etc. Or, to put it another way, once we've grouped and sorted, we can collect the asteroids back together as a list of `(location, direction, index-within-group)` and then sort by `(index-within-group, direction)` (oops, I mean by ``compare `on` ``... ah, you get the point).

The hardest part was staring at the comparison function for the Direction type, and looking at `compare (ax * by) (bx * ay)` and figuring out which operand should go on which side in order for it to work in each quadrant... one of those is larger (as in, further from zero) if one point is closer to the X axis, and the other is closer to the Y axis, or vice-versa... but in two quadrants, being closer to the X axis means you're _more_ clockwise, and in the other two it's _less_... but also in two of the quadrants those values are _negative_ which swaps over which one is bigger (as in, further from negative infinity). And eventually convincing myself that all of this cancelled out, and the same condition was true for all four quadrants without change, as long as both directions were in the same quadrant. And then further simplifying that it was still true if both directions were on the same _half_ of the plane (but if points were on different halves, or either point had x=0, then we have to handle that case separately).
