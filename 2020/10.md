# 10 &ndash; Definitely not an electrical fire risk
Today's puzzle was a lesson in not skim-reading too hard. This was the first puzzle in nearly a week that I was actually around the minute it dropped, so I tried to go for the race again, which made me rush my solution. And as a result, I misread the requirements repeatedly.

In particular, in the first step, I calculated all the differences between the values in the input. But I missed the extra 3-gap from the last adapter to our device. And then I missed the 1-gap from the first adapter to the outlet. And then I typoed an answer because I was rushing. Which added up to an extra three minutes of delay I really didn't need. I don't think that 3 minutes would have been enough on its own to get me on the leaderboard, but it sure would have helped. And then for the second part, I put a `< 3` instead of a `<= 3`, which also took some time to figure out. In short, I made a lot of mistakes I probably wouldn't have made if I'd stopped to actually read properly, and think properly.

But then after all of that, when taking my time and implementing it properly in Haskell for here, the solution came out quite nicely. The first part is just a simple counting exercise, but the second part is interesting as a Dynamic Programming challenge. For example, say we had adapters at 10, 11 and 13, and we'd already figured out how many combinations there are to get to the end from 11 and 13, then we know that the number of combinations to get to the end from 10 is just the sum of those two numbers. So, we can work our way backwards from the end, with there being exactly 1 combination from the very last adapter, and use our calculations for later values to calculate earlier values.

There is, however, a simpler way to do things, which requires noticing that the differences in the input data is _only_ 1s and 3s. The puzzle text doesn't spell that out explicitly, there's nothing in the puzzle that says there aren't any gaps of 2, but it turns out that there aren't any in the input. What this means is that the input consists of a bunch of strings of consecutive numbers, each separated by a gap of 3. This means that endpoints of each string of consecutive numbers represent _mandatory_ adapters (since otherwise you can't bridge the gap), and the decision for which adapters to include in each consecutive run is independent. So you can calculate the options for each consecutive run separately, and multiply them together. And since the only distinguishing feature of each consecutive run is its length, you can just figure out how to calculate the possibilities for each length in advance &ndash; and when you do, you get the [Tribonacci numbers](http://oeis.org/A000073).

That's not how I solved it... I didn't realise that this solution was a possibility until after I'd written the more general solution. But I like that it's there as an option for people able to spot the possibility.
