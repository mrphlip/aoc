# 14 &ndash; So many bitflips!
Doing the first part of this puzzle was relatively straightforward. We make our array to store memory. We read in the masks, converting them to an `andmask` that contains all the `X`s, and an `ormask` that contains all the fixed values (so that `(val & andmask) | ormask` calculates our masked value). Then run through and process all the instructions, to store the appropriately-masked values in the appropriate array locations. And all was well and good.

But then... part two comes up, and now the mask is being applied to the _address_, not the value. Honestly, I should have seen this coming. But now our plan of using an `Array` isn't going to work, because those masks use the full 36-bit range, we'd need to be storing 2<sup>36</sup> memory cells, which is too many. Assuming the array is 64-bit values, that would take up half a terabyte of RAM... and they're probably bigger, since `Integer` is a bignum type.

Well, time to retrofit the code to use `Map` instead of `Array`. What fun! Luckily the interfaces for those two types are very similar... or at least, the parts I'm using are.

To calculate the addresses through the new mask system, we find the list of bits that are set to `X` (remembering these are the bits that are set in `andmask`), and for each one we calculate our list of options for it being unset or set. For instance, if our mask was `0000XX0X` then our list of `X` bits is `[0, 2, 3]` so our options for each bit would be `[[0,1], [0,4], [0,8]]`. We then pass this to `sequence` from the list monad, to transpose this into a list of selections: `[[0,0,0], [1,0,0], [0,4,0], [1,4,0], [0,0,8], [1,0,8], [0,4,8], [1,4,8]]`, and then `sum` these to get our final option values. We then do some more bitmask calculations with the masks and our original unmasked memory address, to get our list of masked memory addresses, and then assign the value to all of these.
