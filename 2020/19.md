# 19 &ndash; Irregular problems and regular expressions
Part 1 of this was solved reasonably straightforwardly by turning the production rules into regular expressions &ndash; the two terminal rules can be rather straightforwardly turned into regexes, and the non-terminal rules can be built from the expressions for the rules that they refer to. This relies on the fact that there are no loops in the rules, which we are explicitly guaranteed.

Of course, in the back of my mind while building this, it seems pretty clear that the second part of the puzzle is going to involve loops, and this strategy is going to fall down. That just seemed like it was clearly being set up as the carpet to be pulled out from under you. And, it turns out to be the case, with two of the rules being replaced with ones that include explicit looping. One of these is a quite simple one-or-more repetition, which can easily be hardcoded into our regex generator as generating a `+` operator. But the second one involves nesting the two patterns in balanced pairs, which is the classic example for something that is _not_ a regular language.

There are ways around this... some regular expression engines have the ability to match some non-regular languages like balanced nesting, with extensions to allow recursion. The engine I'm using here, though, doesn't have this functionality. Another option would be to ditch the regex engine and run a proper parser, but I wasn't excited about doing that either. So I did the cheat method, and assumed that the sample data we had to test could only be nested so far, and picked a limit. So the regular expression generated for rule 11 looks something like `(ab|aabb|aaabbb|aaaabbbb|...)`, up to 10 repetitions. The number 10 is arbitrary, it just needs to be longer than the highest number of repetitions that actually appears in the sample data... and it turns out that 10 is enough.

[8/9]
