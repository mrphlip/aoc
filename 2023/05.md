# 5 &ndash; Green Thumbs
Lots of fun with ranges, here. Managed to successfully avoid getting thoroughly confused mixing up `(start, length)` style ranges with `(start, end)` style ranges... the former being how everything in the puzzle is presented, but the latter being how Python idiomatically does things (and also being just easier to work with for part 2)... In my rush to get race code written, I ended up in the complicated situation where I was using, unprocessed, the map data from the puzzle input, which is `(start, length)`, but all the intermediate ranges I had generated, I had converted to `(start, end)` for ease of processing (and to make `flatten` simpler). So I ended up having to write code to process the intersection between a range from each of the two formats, and come out with the appropriate result. Messy, but it ended up working out just fine.

The strategy for Part 2 is to keep everything in range form as much as possible. Each range is fed into the map, mapping it to a new range in the destination set... which may require splitting the range into several smaller sub-ranges, if our input range crosses a boundary of one of the mapping ranges. To limit the potential growth of the range list, we then "flatten" the output list of ranges, by identifying any ranges that are either neighbouring or overlapping, and combining them into a single range. The algorithm for which is not complicated, but also not immediately obvious, so it was lucky I had expericenced this before and could pull the algorithm from memory.

This process is significantly helped by the fact that, even though the worked example is able to tell you _which_ original seed got mapped through the different values to become the lowest-valued location... you don't actually need to know this, you just need to know what that lowest-valued location is, so you just need to keep some record of the set of points hit at each level, with no eye to the history of how you got to each point.

When I'm setting up for doing the race, each day, usually I'll look at the input first, before I even start to read the actual puzzle, because I know the first task is going to be to take all that data and figure out how to get it into the script. Which meant for today that I opened it up and saw this big list of maps, and I got real scared because it looked like this was going to be some big complex flow network and I'd have to be tracing things through different nodes in some graph... I was halfway through figuring out how to load this all into a big adjacency dictionary before I realised it was just a simple chain, a-to-b, b-to-c, c-to-d... and they were just going to be applied one after the other. Quite the relief.

Also, the easter egg tooltip says "Don't blame me for the weird order. Blame LXC container.conf UID mappings." But I [looked those up](https://linuxcontainers.org/lxc/manpages//man5/lxc.container.conf.5.html#lbBG) and they are listed as `[source range start] [destination range start] [length]`, while the puzzle goes `[destination range start] [source range start] [length]` so I'm not sure that's a thorough excuse... I guess it depends on which of the host and the container you consider the "source" or the "destination" for the mapping?

[27/10]
