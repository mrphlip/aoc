# 10 &ndash; Inside-out
I appear to be unusual in that I found the part 2 of this puzzle noticably easier than the part 1... for most, judging by the leaderboard times, it was definitely the reverse.

For part 1, I started by doing a flood-fill of the path from the starting point, to get a list of all the points that are on the loop. But then I read the instructions again, and realised I needed to find the most distant point on the loop _by path distance_, and not as-the-crow-flies, as I'd initially assumed. Now, if I was thinking clearly I'd realise that this is just half the full loop length, ie half the number of points covered by the flood-fill. But I didn't realise that immediately.

Instead, I threw out the flood fill code entirely, and replaced it with Dijkstra's, to find the most distant point. Which is utterly overkill for a simple loop with no branching, but it's what I thought of at the time. Unfortunately, my implementation of Dijkstra's has a bug in it somewhere, and it only goes around the loop in one direction, and I'm not entirely sure why. I haven't debugged it yet. So it actually comes up with the same answer that the first part did. However, before I got too deep into debugging this, I realised the just-take-half-the-number-of-points trick, and got my answer. So, the code I have committed here, is actually essentially doing a floodfill but with extra steps that resemble Dijkstra, but then throwing all the Dijkstra parts away and just using the floodfill results. If it works, it works.

For part 2, I made use of a simple trick (that I guess isn't as well-known as I thought)... namely that if you pick a point, and draw a ray outward from it, in any direction, and count how many times that ray intersects with the loop, then if the point is inside you'll have an odd number of intersections, and if the point is outside you'll have an even number of intersections. So I just loop through each point, and for the ones that aren't part of the loop, I draw a ray to the right, counting intersections, and then count how many points give me an odd result.

There is a complication, though... my first attempt just traced rightward along the ray and counted how many cells it intersected that were part of the loop. But that doesn't necessarily match up to the actual number of intersections. For instance, if a line ends with something like `.L7`, then that `.` has two cells to its right that are part of the loop, but it's only one intersection, the point is inside. Meanwhile `.LJ` also has two cells to its right that are part of the loop, and this point is _outside_. We need to keep track of each run of connected parts of the loop we run into, and count it as a crossing if one end goes up and the other goes down, but not if they go in the same direction.

However, I realised a shortcut: because we only care about the parity, we could also count every crossing where one end goes up and the other goes down as 1, but then if both ends go up count it as 2, and if both ends go down count it as 0. And that's ultimately the same thing. And then that boils down to "just count how many cells to the right of our cell are in the loop, _and point up_". Looking back at this solution, another way to think of it is that when we trace the ray right from our cell, we intentionally pick a starting point for the ray in _the top half_ of the cell... so it will only cross with cells in the loop that have an upward point.

This got be a pretty speedy result for part 2, which I'm very happy with.

There's certainly optimisations that could be made here... the code is just taking each cell individually, one-by-one, and doing the raycast calculations for each one, which results in a lot of duplicated effort. Like, tracing a ray rightward from `(0,0)` and then tracing the next ray rightward from `(1,0)` is mostly just tracing it over the same cells, and making the same checks. In principle it should only need to do a single raycast across each row, and this would let it determine inside/outside for the entire row. Which would bring the code down from being cubic to quadratic. But code like this is the sort of thing you make when you're racing.

[132/7]

PS: I figured out the bug with the Dijkstra's code... it turns out, I had misread the puzzle. In the worked example of the puzzle, the `S` was replaced with an `F`, so I thought this was what I had to do also, my code just finds the `S` and replaces it with an `F`, and notes its position. However, looking closer at my maze, and reading the puzzle again, I see it's actually _explicitly not specified_ what the neighbours of the `S` square is, and you are supposed to figure it out from what neighbours the cells around it have, and replace it with something that matches. In my case, it should have been a `7`. As it happens, I got lucky, and even though my `S` square should not have had a neighbour to the right, the cell that _is_ immediately to the right was still a part of my loop (the same is not true for the cell immediately _above_ my `S`, for what it's worth). So treating the `S` as an `F` still gave the correct results for the flood-fill, it still found all the cells in the loop, and didn't bleed into any unrelated cells. But this was only due to good luck. And this is why the distance results from Dijkstra were wrong, it wasn't able to go both directions around the loop, as one side wasn't connected properly.
