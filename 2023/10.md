# 10 &ndash; Inside-out
I appear to be unusual in that I found the part 2 of this puzzle noticably easier than the part 1... for most, judging by the leaderboard times, it was definitely the reverse.

For part 1, I started by doing a flood-fill of the path from the starting point, to get a list of all the points that are on the loop. But then I read the instructions again, and realised I needed to find the most distant point on the loop _by path distance_, and not as-the-crow-flies, as I'd initially assumed. Now, if I was thinking clearly I'd realise that this is just half the full loop length, ie half the number of points covered by the flood-fill. But I didn't realise that immediately.

Instead, I threw out the flood fill code entirely, and replaced it with Dijkstra's, to find the most distant point. Which is utterly overkill for a simple loop with no branching, but it's what I thought of at the time. Unfortunately, my implementation of Dijkstra's has a bug in it somewhere, and it only goes around the loop in one direction, and I'm not entirely sure why. I haven't debugged it yet. So it actually comes up with the same answer that the first part did. However, before I got too deep into debugging this, I realised the just-take-half-the-number-of-points trick, and got my answer. So, the code I have committed here, is actually essentially doing a floodfill but with extra steps that resemble Dijkstra, but then throwing all the Dijkstra parts away and just using the floodfill results. If it works, it works.

For part 2, I made use of a simple trick (that I guess isn't as well-known as I thought)... namely that if you pick a point, and draw a ray outward from it, in any direction, and count how many times that ray intersects with the loop, then if the point is inside you'll have an odd number of intersections, and if the point is outside you'll have an even number of intersections. So I just loop through each point, and for the ones that aren't part of the loop, I draw a ray to the right, counting intersections, and then count how many points give me an odd result.

There is a complication, though... my first attempt just traced rightward along the ray and counted how many cells it intersected that were part of the loop. But that doesn't necessarily match up to the actual number of intersections. For instance, if a line ends with something like `.L7`, then that `.` has two cells to its right that are part of the loop, but it's only one intersection, the point is inside. Meanwhile `.LJ` also has two cells to its right that are part of the loop, and this point is _outside_. We need to keep track of each run of connected parts of the loop we run into, and count it as a crossing if one end goes up and the other goes down, but not if they go in the same direction.

However, I realised a shortcut: because we only care about the parity, we could also count every crossing where one end goes up and the other goes down as 1, but then if both ends go up count it as 2, and if both ends go down count it as 0. And that's ultimately the same thing. And then that boils down to "just count how many cells to the right of our cell are in the loop, _and point up_". Looking back at this solution, another way to think of it is that when we trace the ray right from our cell, we intentionally pick a starting point for the ray in _the top half_ of the cell... so it will only cross with cells in the loop that have an upward point.

This got be a pretty speedy result for part 2, which I'm very happy with.

[132/7]
