# 23 &ndash; Full-stack networking
Well, they finally did it. They finally gave me an Intcode problem that required cracking into the main Intcode loop I'd built way back on day 2 and completely restructuring it.

Having inputs come from other processes, or inputs derived from past outputs, we could do that with laziness tricks. But having the ability to do a _non-blocking read_, well that's a lot harder... now we need to have the inputs that the program reads actually depend on the order that things happen... and we can't fake that with laziness tricks, we need to actually run these machines explicitly in parallel and manage their IO queues properly.

At first, I tried to refactor the actual Intcode module, to make it so the input queue could be some more general function... but the approach was fundamentally not really going to work. Whatever that function does, it has to be impure (since it's pulling output from the other machines) and has side-effects (since it needs to consume input from the queue) and the amount of state-passing that was going to require in order to (a) work and (b) stay general enough so we can still just use an ordinary list as input, was just looking infeasible. Or at least beyond my understanding of Haskell for now.

So instead, I leave the core Intcode functions as they are, and change the looping structure around them. I have a function that takes the state of all 50 machines, and processes one instruction in each machine &ndash; using the same `icstep` function from the Intcode module as always, but manipulating the states first before passing them through. In particular, changing the input lists inside the state objects to act as buffers for inputs. And handling the possibility of non-blocking reads by setting the input list to `[-1]` if there's no input in the buffer &ndash; so if the machine reads it'll get `-1`, but if it doesn't we can remove that `-1` from the list before adding new actual values into the input buffer.

We also need to explicitly process the output into pieces in order to do it in lockstep &ndash; we can't just treat the full list of outputs as a lazy list and iterate over it as we need to be able to stop when there's no more outputs _yet_ and then continue afterward. So we buffer outputs alongside each of the machine states, and then process the outputs once there's 3 values in the buffer.

It's all rather complicated, but it works.

For part B, it surprisingly wasn't _that_ complicated to add this to the system. We were already tracking extra information (that output buffer) alongside the machine states, so adding an "is idle" flag to that tuple wasn't too hard. We then set it to "True" if the machine consumes the `-1` we give it (ie, if the input list is empty, so we supply it `[-1]`, then if it changes to `[]` after we call `icstep` then it consumed the input, so set it to idle), and then we reset the idle flag whenever actual data gets added to the input queue. Keeping track of the "NAT" value was also not too much of a challenge. One hiccup is that the machines do go into the all-idle state very soon after starting up &ndash; before any NAT values have actually been set, and the puzzle doesn't specify what happens in this case, it doesn't give any default values. I just set the default values to `-1`s, ie treat it like there is still no values to read, and it seemed to work OK.
