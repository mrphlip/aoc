# 15 &ndash; A maze of twisty little passages, all alike
Fun puzzle today. All the interface stuff for directing the robot around, and keeping a map of what has been found so far, is pretty rote at this point. But the interesting part in figuring out where to send the robot next.

After a couple of false-starts (including, for a while, running the program for day 11 instead of day 15... which also just outputs 1s and 0s so they were accepted just fine, but resulted in an inconsistent nonsense maze) I ended up building a version of Dijkstra's algorithm. Adapting that algorithm to Haskell's way of doing things was interesting, but I managed to build something that works well.

My first implementation worked backwards from the end &ndash; labelling all unknown squares as being "distance 0", so then all of the neighbours to unknown squares had distance 1, etc, until we got to our current location... this then let us follow the trail easily from our location back to the closest unknown point. However, this turned out to be rather inefficient &ndash; if we're, say, 3 squares away from the nearest unknown tile, then before we're done we will have inspected every tile that's <=2 squares away from _any_ unknown tile. Which means every time we follow a long path to a dead-end and have to find our way back, it can take a long time to run.

So instead, we do the reverse &ndash; label our current location as distance 0, and grow out from there, until we hit any unknown square. This has some extra complications, but nothing too severe, and still gives us the same route to the nearest unknown square when we're done (we have to trace from the unknown square back to our starting location, and then reverse the route).

For the final step, once we've explored the entire maze, we can use the same Dijkstra's implementation to find the shortest route from our original starting location to the target, for our puzzle solution.

Initially, I had the exploration stop once we found the target... and, as it happened, this worked just fine for the maze I had in my puzzle. But, in theory, this could have failed, if we hadn't fully explored the shortest path. For instance, if we searched the maze in a path that looked like:
```
######
#....#
#.##.#
#.##.#
#@??*#
######
```
where `#` is a wall, `.` is the floor, `@` is our starting location, `*` is our target, and `?` is an unexplored tile... which is a possible outcome, if we happen to go up for our first step, and continue moving from there, always going to the closest unknown tile, which is further along that hallway, until we reach the target at the end. And then we'd think that the shortest route to the target is 9 steps, when there might be a shorter 3-step direct route, we just haven't explored it. Now, as it happens, the maze in the input seems to have been generated by a simple maze-generating algorithm that doesn't have any loops in it, the maze it generates is a tree, so the direct route is the _only_ route.

But it doesn't hurt to be thorough. So, a quick change and some refactoring later, we then explore the entire reachable maze before finding the route from start to finish. Just for correctness.

Which is great, because Part B then wants us to do some processing on the entire maze, so it's a good thing we have the whole thing explored!

Part B turned out to be quite simple, given we already have Dijkstra's which by design finds a map of the shortest distance from a given location to every other point in the maze &ndash; so we just run that on our oxygen location and find the largest value in the distance map, and we're done.
