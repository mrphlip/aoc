# 18 &ndash; A little maze of twisting passages, all different
OK, this puzzle almost made me give up on this whole endeavour. I didn't do this puzzle on day 18, then I did puzzle 19 on day 19, and then _nothing_ until day 23. After doing puzzle 23, I'm now trying to work back through the backlog... and trying to do this puzzle.

And it makes me sad, because the end result I came up with is, honestly, _very_ procedural. And it's one of the first things I came up with... but I threw out the idea because I'm doing this to learn _functional_ programming, dammit, not to mangle a functional language to write a procedural algorithm! But everything I tried to come up with failed.

So, ultimately, I came up with four different implementations of part A, each being an improvement over the last.

Firstly, we try to brute force it &ndash; we use the Dijkstra's implementation from day 15 to get from one key to the next, but we breadth-first-search every permutation of the accessible keys to find our solution. Works on the small samples, but takes an intractably long time on samples with large numbers of keys.

Second option was to try to dynamic-programming our way through this... because, after all, if we pick up keys A, B, C were in a state, and then if we instead pick up B, A, C, we're in the identical state &ndash; same keys collected, same location in the maze... so we should be able to re-use that branch. First attempt at doing this was to build a statespace graph and use a second level of Dijkstra's on this... but we run into problems, because if there are n keys, then this graph has 2ⁿn nodes (yes or no for each key, and which key was collected last). The majority of those nodes are inaccessible, but they still exist in the space. And creating a data structure to hold all of those possible states is... just too much. Even the large sample, let alone the full puzzle input, completely blows out all the available RAM in my PC.

Third option, go back to the brute force option, try to improve it. Use the fact that our maze is a tree &ndash; there can only be one route from each key to the next, and if there's any closed doors on the way then the route is impossible. There aren't any alternate paths where getting _either_ of two keys can open a route to a new area. So we can precalc the routes between each pair of keys, instead of repeatedly running Dijkstra inside the inner loop. This is a drastic improvement in speed... but still not enough to run even the large sample.

Fourth option, go back to the dynamic programming well, but we need a solution that doesn't create all 2ⁿn nodes. Also, ditch trying to re-use Dijkstra here, it's overkill &ndash; the statespace doesn't have loops, the set of keys we've unlocked can only grow, so just ordinary memoisation is enough, we don't need full pathfinding. But all the Haskell memoisation techniques I can find are based on the same idea &ndash; make a data structure that in theory contains every input/output from the function, and use lazy-eval to actually calculate the options on demand. That works when the primary cost is in actually evaluating the function on a particular input, but less so when it's over a broad range of inputs... laziness means we're not calculating out all 2ⁿn nodes, but if we still have 2ⁿn unevaluated thunks in our datastructure, that's not much of a help. There doesn't seem to be any sort of lazy-evaluated _sparse_ data struture like this, where the domain can be huge, but if we only inspect a handful of cells, they're the only ones that get realised, and the rest are only in-potentia. And I'm not sure how you'd build one and maintain purity.

So, instead, we maintain a memo the old-fashioned way &ndash; the same way I'd do it in a procedural language. The memo is a map from inputs to outputs of our function, and then when we call our function we pull from the memo if it's already there, or we calculate and add it if it's not. But no-side-effects means we need to explicitly pass the memo in _and_ out of each affected function call. And given the function call is multiply-recursive, this is quite complicated. Because we need to pass the memo in to the first recursive call, and then take its output memo and pass it as a parameter to the _next_ recursive call at the same level, and continue like this, taking the memo returned by the _final_ recursive call at that level, adding our own value to it, and returning that. This breaks up a lot of our nice functional flow... using the list monad as an implicit `map` with all our fancy logic, because we need to be passing this state (the updated memo) from each loop to the next. I suppose "proper" functional programming would be some kind of fancy `fold` here, but this was complicated enough without trying to wrap my brain around that, so instead I just broke it all down, and built something depressingly-procedural-looking doing the iteration from first principles. The code kinda sucks. But it works, this was the only solution that was fast enough to actually finish the puzzle.

With all that mess done, part B wasn't ultimately that hard. Most of the bulk of the work is done, we just need to expand our state to have the locations of the four robots, and expand our pre-calculated routes to include the four starting locations we could come from. The ultimate shape of the code is roughly the same, and it takes about the same amount of time to run.
