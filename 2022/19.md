# 19 - Geode clicker
And yesterday's reprieve was shortlived, we're back on that difficulty spike train again. And, much like [day 16](16.md), we have a weird pathfinding expedition through an complex state-space, with no particularly obvious (to me) shortcuts to just searching the space for the optimal path.

And, much like day 16, the naive implementation was taking way too long to run, and was hurting my brain trying to find optimisations. My simple solution was able to figure out the optimal route for the first sample blueprint, but not the second one... that one was just too cheap for the basic bots, there were too many options to tread through. And that wasn't a good sign for trying to run it over my actual input, which included some blueprints that were as cheap if not cheaper.

It was at about the 45-minute mark that I finally spotted the main optimisation that made the problem tractable: there's an upper limit to how many bots (of any type other than geode) it's worth building. For example, if the obsidian bot costs 5 clay, then there's no point in having more than 5 clay bots, they'd just be pumping out resources that you can't spend quickly enough. That significantly pruned the search-space, for the cheaper cards... like, even if you manage to get enough ore production that you can make a new clay bot every minute, which should crank up the exponential growth of the state space a ton, the system will stop considering making more clay bots after a time, which limits that growth before it gets out of hand.

So then we hit my final issue: my code was generating the right answer for the first sample blueprint, but it was giving the wrong answer for the second. and I couldn't figure out why. All the code seemed fine. And the puzzle text gave a detailed workthrough of the first blueprint, but not for the second, all it gave was the final number. It wasn't until about the one-hour-ten mark that I finally figured it out: I had a typo in the sample data. I had typed that the geode bot cost 13 obsidian, instead of 12. Ugh. Fixed that, and the code just worked, gave me the right answer. And part 2 was pretty simple after that as well.

Sigh.

My one saving grace is that this wasn't the clincher for the leaderboard... I'd spent enough time legitimately stuck on the puzzle that even if I didn't have the typo, it wouldn't have hit top 100. But all the same, it still stings. Especially because normally, I copy-paste that sort of thing from the puzzle page, rather than retyping it, specifically to avoid that sort of thing, but in this particular case I just didn't want to go through the process of munging the data into the python tuples again, and anyway, it's just 12 numbers, quicker to just retype it... well, I know not to make that mistake again.

Much like day 16, I don't think I'll be bothering to reimplement this one in Haskell. And in general, I'll probably be rethinking my whole plan of race-in-Python-then-rebuild-in-Haskell... I just don't feel like I'm really gaining anything from the Haskell solutions any more. I still don't feel like I'm, like, good at Haskell, by any means, but I don't feel like doing the AoC puzzles in it is teaching me anything new any more. It just feels like a chore, more than anything. I'll probably see out the rest of this event, but by next year I'll have to have a think about what I want my plan to be going forward.

[480/299]
