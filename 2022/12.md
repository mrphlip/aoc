# 12 &ndash; Gradient ascent
Ah yes, can't get this far into an AoC without a classic shortest-path puzzle. Such a classic that by this point I can just rattle off a dodgy poorly-optimised implementation of Dijkstra in my sleep. Because, to be sure, the implementation in my Python race code is dodgy and poorly-optimised, but it works, and that's all that matters.

Naturally, for part 1, I ran Dijkstra directly, starting at the start location and running until we find the end. So, of course, part 2 involves fixing the _end_ location and checking a whole bunch of _start_ locations. Which Dijkstra can do just fine, you only have to fix one endpoint and it finds the minimum distances to every other point on the graph if you let it run to completion. But that did require some quick swapping of variables and negating of conditions to make it run backwards from the end instead of forwards from the start. There was also a slight hiccup that the graph isn't fully connected... it's not possible to reach the endpoint from every candidate startpoint, which means the Dijkstra loop needs to bail before it's completely filled out the distance map. In lieu of an actually good way to handle this, I just catch the exception that's raised when it runs out of candidates and bail at that point.

For the Haskell re-implementation, it was even easier, since I have this handy Dijkstra module that I've built up from previous AoCs, which conveniently even has a function for calculating a full distance map from a given point. Was just a case of plugging everything into the appropriate places.

[40/64]
