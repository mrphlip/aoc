# 13 &ndash; Weird comparators
Reading the reactions to this one, the responses seem very split... between people using dynamically-typed interpreted languages, which can just read the packets from the input as-is (either by just pasting them into the code, as I did, or with something like `eval`)... vs statically-typed languages that have to come up with a structure to represent these mixed-type lists in memory, and then parse the input into that. Major differences in opinion, there.

During the race, for part 1, I was writing the comparison function, and I just by force of habit wrote it as a standard comparison function... ie negative result means less-than, zero means equal, positive means greater-than. No reason it _had_ to be that way, but it had to return something, may as well be that. Which was convenient, because that meant that part 2 was easy, just have to sort using that comparison function. Except that sorting using a comparison function was removed in Python 3, you're supposed to use a `key` function instead... but turning this particular comparison function into a key function is not particularly feasible. Which, honestly, is the first time in however many years of coding with Python 3 that I have missed `sort(cmp=...)`, and all it took was a super-contrived conding puzzle. Luckily, though, I've done a fair amount of work with convering Python 2 codebases to Python 3, and working with `2to3`, which has informed me about the evil magic that is `functools.cmp_to_key`, so just threw that on and it all worked.

Reimplementing in Haskell, I was able to get quite cheeky with it... as I was able to lift both the `read` and `compare` implementations that are already built into the language for integers and lists, and whamjangle them together into doing exactly what we want... so the actual code doesn't seem to be doing a lot, as most of the actual magic has been lifted directly from the standard library.

[23/9]
