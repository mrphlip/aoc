# 22 &ndash; Banana

Ah, another nice simple one, to recover from yesterday's madness.

A quick look at that PRNG certainly looked like it wasn't going to be particularly easy to do any analysis to, so I just implemented it as written and hoped I wouldn't need to. And this instinct turned out to be well-founded, looking into it after the fact I see this is a standard PRNG style, called [Xorshift](https://en.wikipedia.org/wiki/Xorshift) (though the specifics are custom, none of the standard Xorshift PRNGs go down to 24-bits, the smallest is Xorshift32).

A 24-bit seed space also seemed large enough that adding caching to the step function seemed like it wouldn't help much, but also small enough that I would not have been surprised to see part 2 requiring me to enumerate an entire loop of the RNG sequence and do something with that information. Luckily, neither of these turned out to be relevant for what the puzzle wanted me to do.

Part 1 is pretty straightforward, just implement the RNG as specified, and iterate it 2000 times on each number as directed. My one and only nod to efficiency was to swap the order of the `mix` and `prune` operations (since it's equivalent) but that didn't speed it up much (if I had thought about it, I could have also replaced the multiplications and divisions with bitshifts, and made this really look like a Xorshift implementation, but it wasn't necessary so I didn't bother).

For part 2, the main difficulty was reading the puzzle quickly and figuring out what they actually wanted, but having got that, the implementation was pretty straightforward. The scariest part while reading the instructions is that it talks about what will happen if the monkey "never" sees a given pattern in the output... and it's only a couple paragraphs later that it says it's still only generating 2000 random numbers from each seed. I was worried I'd have to potentially run the RNG forever (or until it looped) in order to detect this "never" condition (or, also unrealistically, do enough analysis of the RNG behaviour to be able to determine if a particular pattern would ever show up). Was quite a relief to keep reading and discover that wasn't the case.

It was pretty clear to me right off the bat that the direct approach of "pick a particular target sequence, then run all the monkeys looking for that target, and see what the result is, repeat for different target sequences to find the max" was going to be a bad idea. So instead, we go from each seed and generate the full 2000 random numbers, and keep a running record of the last 4 differences, and build up a dictionary of each sequence, and the value at that point. But only the first time each sequence is seen... if we see a sequence again, we don't replace it in the dictionary. The end result is a big dictionary of how much that buyer would pay, given _any_ potential target sequence (and also the knowledge that they would pay 0 for any sequence that does not appear in the dictionary), all in one pass through the RNG sequence.

Do this for each of the seeds and add them all up, and we have our final total for every possible target sequence, and we just have to pull out the maximum. Nice.

[158/68]
