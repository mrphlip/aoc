# 23 &ndash; Finding the popular kids in school

Ah, nice, I was waiting for a good graph theory challenge to sink my teeth into.

Doing a first pass and loading in all the info, I wasn't sure what form would be best to store it in. I decided to hedge my bets and make both an adjacency set (ie `{(i, j) where i, j are connected}`) and a neighbour dictionary (ie `{i: {j} where i,j are connected}`), making sure to insert all the edges in both orders. This ended up being quite useful as I ended up using both data structures for different parts of the script.

For part 1, I attacked this pretty directly, going through each node, then going through each of that node's neighbours, then going through each node that's a neighbour of both of the other nodes. This gives a list of all the connected triplets of nodes. I also arbitrarily require the nodes to come out in ascending order, to make sure each triplet is only counted once. Then quickly bolting in the final condition that one of the nodes starts with `t` and we're done.

I suspect this could have been more efficient if we _started_ with the first node only looping through the nodes that start with `t` and work out from there, but (1) I hadn't read the `t` requirement when I started writing the loop, and (2) it would have made de-duping the list a little less clean (especially in possibility where there's two `t` nodes in the same triple)... and it was fast enough without this, so I'm glad I didn't bother.

For part 2... I was concerned. I didn't know if there was a good, efficient algorithm for this, and nothing immediately sprung to mind. So I did what I could, and made a very basic search to essentially enumerate every complete subgraph of our network, and then filter for the largest one. I knew this wasn't particularly efficient (depending on the shape of the network, it could be anywhere up to `O(2^n)`, and the network has, like, 3300 nodes in it), but the biggest impact on the performance of the algorithm is the size of the largest cliques, if all the cliques are small then the call tree of the search can't branch out as far and it'll run a lot faster, so I just prayed that the largest cliques in the network weren't too big, and set it running.

In the meantime, I went searching for a more efficient solution. While I didn't know a good algorithm offhand, I at least knew the right lingo to Google to get more info. I got as far as the [Wikipedia page for the maximal clique problem](https://en.wikipedia.org/wiki/Clique_problem) and seeing subheadings like "NP-completeness" and "Hardness of approximation" didn't give me a lot of hope looking forward. But, luckily, that's as far as I got before my simple algorithm finished (it actually only took 11 seconds, there was probably some time lost before I even noticed it was finished).

[239/193]
