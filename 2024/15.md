# 15 &ndash; SokoBIG

Ooh, a nice fun one today.

Part 1 was pretty nice and easy, though I did misread the instructions in my haste... I saw the step list was split up over mutliple lines, so I assumed those were separate scenarios, and then in skimming the instructions for what to do abotu the different scenarios, I spotted the word "sum" in the final instruction ("what is the sum of all boxes' GPS coordinates?") so I assumed the puzzle was: run the grid for each scenario, and sum their resulting GPS values together. So my code is built to be re-runnable, and work on a copy of the grid so that multiple runs can be done from the same starting position. At least it was still nice for working on part 2, being able to immediately go on without part 1 having moved everything around first.

Movement in part 1 is relatively straightforward &ndash; we check for boxes in the appropriate direction, and count how many boxes there are. If there's a `#` behind all the (zero or more) boxes, we don't move, but if there's a `.` then we move the boxes down by one (by writing a `O` into that empty space at the end, and replacing the first box with a `.`) and move the robot by a step. Nice.

For part 2, it's a bit more complicated, especially when moving up or down, since a box can push on two other boxes (which can then in turn each push on two more boxes, in which case the same box is being pushed twice by two different boxes)... all looks complicated. So we do it in multiple passes. First, use a recursive search to find all of the boxes that will have to be moved. Then, we do a pass to remove all the boxes from their current position (replacing them with `..`) and then a second pass to write all the boxes into their new position (as `[]`). The moving is done in two passes like this instead of moving each box individually, to avoid having to ensure we do them in the right order (if box A pushes into box B, we'd have to move B before A, otherwise we'd move box A over the top of box B, and then when we move box B by replacing it by `..` then part or all of box A would end up missing... this is possible to work around but it's fiddly when you can have boxes pushing multiple boxes and pushed by multiple boxes).

I did have an exciting bug here, where a box was being pushed left, and the right half of the box would try to push against the left half of the _same box_, and so the recursive scan of what boxes are being pushed would recurse forever. That was a fun one to figure out, but it's resolved by just not considering the right half when moving left, or the left half when moving right.

[174/22]
