# 22 &ndash; Every day, I'm shuffling
I recognised the trick to this puzzle very quickly &ndash; all three of the shuffles we have are affine transformations of our card deck, modulo the size of the deck.

What this means is that, if you know where cards 0 and 1 end up, you can figure out where all the rest of the cards are. If card 0 is at position _n_, and then card 1 is at position _n_+_i_, then card 2 will be at position _n_+2_i_, card 3 will be at position _n_+3_i_, and so on. With positions beyond the bounds of the deck wrapping around to the other end. All three shuffles we have maintain this invariant &ndash; any order of the cards we can end up with can be described with just these two numbers _n_ and _i_.

Part B then adds three changes &ndash; firstly, the size of the deck is increased. Then, the list of shuffles is repeated many times, and finally we're being asked "what card is in position _p_" rather than "in what position is card _x_" which part A asked.

The first of these complications is essentially irrelevant &ndash; since we're already only keeping track of two cards, increasing the size of the deck doesn't matter.

The second can be solved easily by observing that we can easily _combine_ two sequences of shuffles into a single result. If we have one sequence of shuffles that would put card A in position B, and a second sequence of shuffles that would put card B in position C, then performing _both_ shuffles in sequence would put card A in position C. Since we only need to keep track of two cards, we just need to see where cards 0 and 1 end up after the first shuffle (which we already have) and then see where those positions would be taken after the second shuffle (we already have a calcultion for "in what position is card _x_" from part A).

The last is a little more complicated, as we need to do a division &ndash; if card _x_ is in position _p_ = _n_ + _i_ * _x_, then the reverse of this is that the card in position _p_ is _x_ = (_p_ &minus; _n_) / _i_. Happily, there exists a standard algorithm involving the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm), for finding the multiplicative inverse modulo some number, so we use that.
