# 14 - Dependency trees
Some interesting mental juggling here to get everything into place, but ultimately not too complicated once everything was fitted into place.

Honestly, the hardest part of this puzzle was parsing the input file. Up until now, the input file formats have been very simple (eg an Intcode machine is just numbers separated by commas). The one exception, on day 12, was very short (just the initial positions of the 4 moons) so I just processed it by hand and hardcoded it into Haskell source. But this one was long enough that I wanted to actually write a parser for it, and simple enough that I thought I could figure it out.

The reader that I ended up writing was quite long and complicated... I'm sure it could be made a lot shorter by use of some sort of parsing library, but (a) I don't know what parsing libraries are available that are simple to use, (b) I haven't even really figured out how to use libraries at all in Haskell yet, and (c) it's educational to do it from scratch at least once. So I have this nested chain of `ReadS` monads.

Once we have the puzzle actually parsed, now it's on to solving it. The plan is, to substitute in the recipe for each necessary reagent, until there are none left except the ore. Benevolent puzzle creator gave us a dependency tree where (a) each production only has a single output (even if there are many inputs), (b) each output only appears once, (c) there are no dependency loops.

Only a single output means we can make a lot of simplifying assumptions - in particular, we don't have to worry about any sort of catalyst effect, that is an input that has to be there for us to do the reaction, but is still there when we are done. If we could have a reaction like `1 A, 1 B => 1 C` and `1 C => 1 D, 1 A` then we could combine these to turn `B` into `D` as long as we have an `A`, but it doesn't consume it... which makes things more complicated. In particular, it would mean that we'd need to keep a strict order on the reactions being performed - if we had multiple catalysing reactions, they could be performed in sequence with only a single catalyst, but if we had to interleave them we'd need more catalysts. All in all, the problem of finding the optimal order of operations would be a lot harder.

However, with the puzzle as it is, if there's extra outputs hanging around other than the fuel we're trying to create, it must be just leftovers from other reactions (eg one reaction wanted `4 A` but we could only make `A` in batches of 10, so we have `6 A` left over), so we can safely use that as an input for any other reaction that wants to use the same reagent. And, similarly, if we ever come up with something on both sides of the production, it can be safely removed (eg `5 A, ... => 2 A, ...` can be reduced to `3 A, ... => ...`).

On the other hand, no dependency loops means we don't need to be careful about what order we simplify our equation - we can't substitute out `A` by replacing it with `B`, and then substitute out `B` and replace it with `A`. But since there are no loops, following the trail of dependencies has to eventually end.

This means we can simply pick one of the reagents that has a recipe in the puzzle (which should be all of them except `ORE`), substitute it in, keep track of all the necessary reagents and any leftovers the recipe might give us, and repeat until all we're left with on the left side of the arrow is `ORE`.

For part B, we can't just multiply throughout because we will be able to make use of our extra leftovers on subsequent reactions. Consider, say, `2 ORE => 2 A`; `3 A => 1 FUEL`. In order to make 1 fuel will take 4 ore. But in order to make 2 fuel will only require 6 ore, as the second fuel can use the leftover `A` that the first fuel created. Multiply this by a multi-layer dependency tree and now there is a lot of complications to directly calculating this out.

There are two ways to do this - the direct way is to run the reaction one step at a time, and only cascade down to the dependencies if there aren't any left-overs around to use. And just keep running through the process until we run out of ore. This will work, but it will effectively take linear time in the amount of ore available - and we have literally a trillion ore to get through. Not ideal.

However, a faster solution is to work backwards - we already have a solver to tell us what the costs are to build a particular target. Tell it to build "n fuel" and keep increasing the n until we can't any more. If we increase it one by one, it's effectively the same as the previous solution, but we don't have to - we can try any number for n that we want. So we use an exponential growth, trying to get 2 fuel, then 4, then 8... until we find an upper bound, an amount we can't afford to make. And then we use a binary search to narrow down that range to the cutover - the maximum amount of fuel we can afford, but one more and we can't.
